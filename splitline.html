<!DOCTYPE HTML>
<html xml:lang="en" lang="en">
<head>
	<title>CSE442 | Final The Shortest Splitline Algorithm</title>
</head>

<style>

#map{
    overflow: auto;
}


svg{
    display: block;
    margin: auto;
}

</style>

<body>
	<div class="content">


		<section>
                <svg width="600" height="400" border = "1" ></svg>
				<script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
				<script type="text/javascript" src='https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js'></script>
				<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
				<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
				<script src="https://d3js.org/d3.v4.min.js"></script>
				<script src="https://d3js.org/topojson.v2.min.js"></script>
				<script src="https://d3js.org/d3-array.v1.min.js"></script>
				<script src="https://d3js.org/d3-geo.v1.min.js"></script>

				<script>
                    
                    //var map = document.getElementById("map");
                    var pop = 100;
                    var points = [];
                    
                    var svg = d3.select("svg");
                    
                    var borderPath = svg.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("height", 400)
                    .attr("width", 600)
                    .style("stroke", "pink")
                    .style("fill", "none")
                    .style("stroke-width", 1);
                    
                    for(i=0; i<pop; i++){
                        points[i] = {x: Math.floor(Math.random() * 601), y: Math.floor(Math.random() * 401), party: Math.floor(Math.random() * 2)};
                    }
                    
                    svg.selectAll(".pin").data(points)
                    .enter().append("circle", ".pin")
                    .attr("r", 3)
                    .attr("transform", function(d) {
                        return "translate(" + 
                            d.x
                            + ", " +
                            d.y
                         + ")"
                    })
                    .attr("fill", function(d) {
                        if(d["party"] == 0){
                            return "blue"
                        }
                        else{
                            return "red"
                        }
                    })
                    
                    var startShape = [[0, 0], [600, 0], [600, 400], [0, 400]]
                    
                    for(i = 0; i<startShape.length; i++){
                        svg.append("line")
                        .attr("x1", startShape[i][0])
                        .attr("y1", startShape[i][1])
                        .attr("x2", startShape[(i+1)%startShape.length][0])
                        .attr("y2", startShape[(i+1)%startShape.length][1])
                        .attr("style", "stroke:pink; stroke-width:2")
                    }
                    
                    splitShape(startShape, points, 7);
                    
                    function splitShape(corners, pop, numdist){
                        if(numdist == 1){
                            return;
                        }
                        var maxx = 0;
                        var maxy = 0;
                        var minx = 600;
                        var miny = 400;
                        for(var i = 0; i<corners.length; i++){
                            if(corners[i][0] > maxx){
                                maxx = corners[i][0];
                            }
                            if(corners[i][1] > maxy){
                                maxy = corners[i][1];
                            }
                            if(corners[i][0] < minx){
                                minx = corners[i][0];
                            }
                            if(corners[i][1] < miny){
                                miny = corners[i][1];
                            }
                        }
                        var smaller = Math.floor(numdist/2);
                        var larger = numdist - smaller;
                        var goal = Math.floor(smaller/numdist * pop.length);
                        console.log(goal);
                        var splitlines = [];
                        for(var i = minx; i<maxx; i++){
                            for(var j = miny; j<maxy; j++){
                                var above = 0;
                                for(var k = 0; k<pop.length; k++){
                                    if(maxx != i && pop[k].y > ((j-miny)/(maxx-i))*(pop[k].x-i)+miny){
                                        above++;
                                    }
                                }
                                if(above == goal || above == pop.length-goal){
                                    splitlines[splitlines.length] = {x1: i, y1: miny, x2: maxx, y2: j};
                                }
                            }
                            for(var j = minx; j<maxx; j++){
                                var above = 0;
                                for(var k = 0; k<pop.length; k++){
                                    if(j != i && pop[k].y > ((maxy-miny)/(j-i))*(pop[k].x-i)+miny){
                                        above++;
                                    }
                                }
                                if(above == goal || above == pop.length-goal){
                                    splitlines[splitlines.length] = {x1: i, y1: miny, x2: j, y2: maxy};
                                }
                            }
                            for(var j = miny; j<maxy; j++){
                                var above = 0;
                                for(var k = 0; k<pop.length; k++){
                                    if(minx != i && pop[k].y > ((j-miny)/(minx-i))*(pop[k].x-i)+miny){
                                        above++;
                                    }
                                }
                                if(above == goal || above == pop.length-goal){
                                    splitlines[splitlines.length] = {x1: i, y1: miny, x2: minx, y2: j};
                                }
                            }
                        }
                        
                        for(var i = miny; i<maxy; i++){
                            for(var j = miny; j<maxy; j++){
                                var above = 0;
                                for(var k = 0; k<pop.length; k++){
                                    if(maxx != minx && pop[k].y > ((j-i)/(maxx-minx))*(pop[k].x-minx)+i){
                                        above++;
                                    }
                                }
                                if(above == goal || above == pop.length-goal){
                                    splitlines[splitlines.length] = {x1: minx, y1: i, x2: maxx, y2: j};
                                }
                            }
                            for(var j = minx; j<maxx; j++){
                                var above = 0;
                                for(var k = 0; k<pop.length; k++){
                                    if(j != minx && pop[k].y > ((maxy-i)/(j-minx))*(pop[k].x-minx)+i){
                                        above++;
                                    }
                                }
                                if(above == goal || above == pop.length-goal){
                                    splitlines[splitlines.length] = {x1: minx, y1: i, x2: j, y2: maxy};
                                }
                            }
                        }
                        
                        for(var i = miny; i<maxy; i++){
                            for(var j = minx; j<maxx; j++){
                                var above = 0;
                                for(var k = 0; k<pop.length; k++){
                                    if(j != maxx && pop[k].y > ((maxy-i)/(j-maxx))*(pop[k].x-maxx)+i){
                                        above++;
                                    }
                                }
                                if(above == goal || above == pop.length-goal){
                                    splitlines[splitlines.length] = {x1: maxx, y1: i, x2: j, y2: maxy};
                                }
                            }
                        }
                        var minLine = [{x1: 0, y1: 0, x2: 0, y2: 0}];
                        var minLen = 10000000000;
                        var oldLine = {x1: 0, y1: 0, x2: 0, y2: 0};
                        
                        for(var i = 0; i<splitlines.length; i++){
                            var inters = [];
                            for(j = 0; j<corners.length; j++){
                                var inter = calculateIntersectionPoint(splitlines[i].x1, splitlines[i].y1, splitlines[i].x2, splitlines[i].y2,
                                                            corners[j][0], corners[j][1], corners[(j+1)%corners.length][0], corners[(j+1)%corners.length][1]);
                                if (inter != null){
                                    inters[inters.length] = inter;
                                }
                            }
                            if(inters.length == 2){
                                var tmp = splitlines[i];
                                splitlines[i] = {x1: inters[0][0], y1: inters[0][1], x2: inters[1][0], y2: inters[1][1]}
                                var len = Math.pow((splitlines[i].x2-splitlines[i].x1), 2) + Math.pow((splitlines[i].y2-splitlines[i].y1), 2);
                                if(len<=minLen){
                                    minLen = len;
                                    minLine = [splitlines[i]];
                                    oldLine = tmp;
                                }
                            }
                        }
                        var flag = true;
                        if(minLine[0].x1 != minLine[0].x2 && corners[0][1] <= ((minLine[0].y2-minLine[0].y1)/(minLine[0].x2-minLine[0].x1))*(corners[0][0]-minLine[0].x1)+minLine[0].y1){
                            flag = false;
                        }
                        var stateA = [];
                        var stateB = [];
                        for(i = 0; i<corners.length; i++){
                            var inter = calculateIntersectionPoint(oldLine.x1, oldLine.y1, oldLine.x2, oldLine.y2,
                                                        corners[i][0], corners[i][1], corners[(i+1)%corners.length][0], corners[(i+1)%corners.length][1]);
                            
                            if(flag){
                                stateA[stateA.length] = corners[i];
                            }
                            else{
                                stateB[stateB.length] = corners[i];
                            }
                            if (inter != null){
                                stateA[stateA.length] = [Math.floor(inter[0]), Math.floor(inter[1])];
                                stateB[stateB.length] = [Math.floor(inter[0]), Math.floor(inter[1])];
                                flag = !flag;
                            }
                        }
                        var abovePt = [];
                        var belowPt = [];
                        
                        for(var k = 0; k<pop.length; k++){
                            if(minLine[0].x1 != minLine[0].x2 && pop[k].y > ((minLine[0].y2-minLine[0].y1)/(minLine[0].x2-minLine[0].x1))*(pop[k].x-minLine[0].x1)+minLine[0].y1){
                                abovePt[abovePt.length] = pop[k];
                            }
                            else{
                                belowPt[belowPt.length] = pop[k];
                            }
                        }
                        
                        svg.selectAll(".split").data(minLine)
                        .enter().append("line", ".split")
                        .attr("x1", function(d) {
                            return Math.floor(d.x1)
                        })
                        .attr("x2", function(d) {
                            return Math.floor(d.x2)
                        })
                        .attr("y1", function(d) {
                            return Math.floor(d.y1)
                        })
                        .attr("y2", function(d) {
                            return Math.floor(d.y2)
                        })
                        .attr("style", "stroke:pink; stroke-width:2")
                        console.log(abovePt);
                        console.log(belowPt);
                        console.log(stateA);
                        console.log(stateB);
                        if(abovePt.length >= belowPt.length){
                            splitShape(stateA, abovePt, larger);
                            splitShape(stateB, belowPt, smaller);
                        } 
                        else{
                            splitShape(stateA, abovePt, smaller);
                            splitShape(stateB, belowPt, larger);
                        }
                    }
                    
                    function calculateIntersectionPoint(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
                        var denominator, a, b, numerator1, numerator2, result = {
                            x: null,
                            y: null,
                            onLine1: false,
                            onLine2: false
                        };
                        denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
                        if (denominator == 0) {
                            return result;
                        }
                        a = line1StartY - line2StartY;
                        b = line1StartX - line2StartX;
                        numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
                        numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
                        a = numerator1 / denominator;
                        b = numerator2 / denominator;

                        result.x = line1StartX + (a * (line1EndX - line1StartX));
                        result.y = line1StartY + (a * (line1EndY - line1StartY));
                        if (a >= 0 && a <= 1) {
                            result.onLine1 = true;
                        }
                        if (b >= 0 && b <= 1) {
                            result.onLine2 = true;
                        }

                        if(result.onLine1 && result.onLine2){
                            return [result.x, result.y];
                        }
                        else{
                            return null;
                        }
                    };
                    
				</script>

			

		</section>

		<div class="footer">
		</div>
	</div>
</body>
</html>